strategy = simul_results$strategy[1], forager = for_num, level = lvl,
nn_weight = simul_results$nn_weight[1],
ta_weight = simul_results$ta_weight[1], clst_weight = simul_results$clst_weight[1],
pv_weight = simul_results$pv_weight[1], obj_ID = 0, x = 0, y = 0, time = 0, dist = 0,
point_value = 0, points = 0,
.before = 1
) |>
slice_head(n=col_num+2)
if(cov == 'dist') {
# look at nn
p <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value)) |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = (1/distance),
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Distance value', low = clrs[6], high = '#E7D22E', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'ta') {
# look at ta
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
# determine which would be used
if(opt != 'orig_choice') {
# find which coconut would be chosen
df$used <- vector('numeric', length = length(df$turning_angle))
df$used[which.max(cos(df$turning_angle))] <- 1
}
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = cos(turning_angle),
shape = as.factor()
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Turning angle value', low = clrs[4], high = '#C4DEF1', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'clst') {
# look at nn
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
# set scale
min.val = min(df$neighbor_value)+.1
max.val = max(df$neighbor_value)-.1
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = neighbor_value,
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Cluster value', low = clrs[1], high = '#C4ECAB', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
}
return(p)
}
plot_cov_and_path(0, 10, 2, cov = 'ta', opt = 'ta_choice')
df <- expanded_df |>
filter(strategy == 'nn' & forager == 0 & level == 10) |>
left_join(arrangements, by = join_by(level, obj_ID, point_value))
df <- expanded_df |>
filter(forager == 0 & level == 10 & collection_num == 1) |>
left_join(arrangements, by = join_by(level, obj_ID, point_value))
df$used <- vector(0, length = length(df$turning_angle))
df$used <- vector('numeric', length = length(df$turning_angle))
View(df)
df$used[which.max(cos(df$turning_angle))] <- 1
View(df)
rlang::last_trace()
plot_cov_and_path <- function(
for_num, lvl, col_num, cov = 'dist', path=simul_results, exp_df=expanded_df,
arr=arrangements, opt='orig_choice'
) {
strat <- unique(exp_df$strategy)
# filter for path
path_df <- path |>
filter(strategy == strat & forager == for_num & level == lvl) |>
add_row(
strategy = simul_results$strategy[1], forager = for_num, level = lvl,
nn_weight = simul_results$nn_weight[1],
ta_weight = simul_results$ta_weight[1], clst_weight = simul_results$clst_weight[1],
pv_weight = simul_results$pv_weight[1], obj_ID = 0, x = 0, y = 0, time = 0, dist = 0,
point_value = 0, points = 0,
.before = 1
) |>
slice_head(n=col_num+2)
if(cov == 'dist') {
# look at nn
p <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value)) |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = (1/distance),
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Distance value', low = clrs[6], high = '#E7D22E', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'ta') {
# look at ta
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
# determine which would be used
if(opt != 'orig_choice') {
# find which coconut would be chosen
df$used <- vector('numeric', length = length(df$turning_angle))
df$used[which.max(cos(df$turning_angle))] <- 1
}
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = cos(turning_angle),
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Turning angle value', low = clrs[4], high = '#C4DEF1', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'clst') {
# look at nn
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
# set scale
min.val = min(df$neighbor_value)+.1
max.val = max(df$neighbor_value)-.1
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = neighbor_value,
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Cluster value', low = clrs[1], high = '#C4ECAB', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
}
return(p)
}
plot_cov_and_path(0, 10, 2, cov = 'ta', opt = 'ta_choice')
plot_cov_and_path <- function(
for_num, lvl, col_num, cov = 'dist', path=simul_results, exp_df=expanded_df,
arr=arrangements, opt='orig_choice'
) {
strat <- unique(exp_df$strategy)
# filter for path
path_df <- path |>
filter(strategy == strat & forager == for_num & level == lvl) |>
add_row(
strategy = simul_results$strategy[1], forager = for_num, level = lvl,
nn_weight = simul_results$nn_weight[1],
ta_weight = simul_results$ta_weight[1], clst_weight = simul_results$clst_weight[1],
pv_weight = simul_results$pv_weight[1], obj_ID = 0, x = 0, y = 0, time = 0, dist = 0,
point_value = 0, points = 0,
.before = 1
) |>
slice_head(n=col_num+2)
if(cov == 'dist') {
# look at nn
p <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value)) |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = (1/distance),
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Distance value', low = clrs[6], high = '#E7D22E', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'ta') {
# look at ta
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
# determine which would be used
if(opt != 'orig_choice') {
# find which coconut would be chosen
df$used <- vector('numeric', length = length(df$turning_angle))
df$used[which.max(cos(df$turning_angle))] <- 1
df$used[is.na(df$turning_angle)] <- NA
}
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = cos(turning_angle),
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Turning angle value', low = clrs[4], high = '#C4DEF1', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
} else if(cov == 'clst') {
# look at clst
df <- exp_df |>
filter(forager == for_num & level == lvl & collection_num == col_num) |>
left_join(arr, by = join_by(level, obj_ID, point_value))
if(opt != 'orig_choice') {
# find which coconut would be chosen
df$used <- vector('numeric', length = length(df$turning_angle))
df$used[which.max(df$neighbor_value)] <- 1
df$used[is.na(df$turning_angle)] <- NA
}
p <- df |>
ggplot() +
geom_path(
data = path_df, aes(x = x, y = y), linewidth = .2,
arrow = arrow(type = 'closed')
) +
geom_point(
aes(
x = x, y = y, size = as.factor(point_value), color = neighbor_value,
shape = as.factor(used)
)
) +
scale_shape_manual(
'Chosen?', labels = c('No', 'Yes', 'Current\nposition'),
values = c(16, 17), na.value = 13
) +
scale_size_discrete(guide = 'none', range = c(3,5)) +
scale_color_gradient(
'Cluster value', low = clrs[1], high = '#C4ECAB', na.value = 'black'
) +
guides(
color = guide_colorbar(
order = 1, direction = 'horizontal', position = 'top'
),
shape = guide_legend(
override.aes = list(size = 3), order = 2, position = 'top'
)
) +
theme_void() +
theme(
text = element_text(family = 'Aptos'),
legend.text = element_text(size = 10),
legend.title = element_text(size = 14, face = 'bold'),
legend.title.position = 'top',
legend.text.position = 'bottom',
legend.margin = margin(t = 0, b = 0, r = 10, l = 10)
)
}
return(p)
}
plot_cov_and_path(0, 10, 2, cov = 'clst', opt = 'cov_choice')
plot_cov_and_path(0, 10, 2, cov = 'ta', opt = 'cov_choice')
ggsave(
'fig_output/simulation/nn_strat_ta_valuation.pdf', device = 'pdf',
width = 6, height = 6.6, units = 'in'
)
plot_cov_and_path(0, 10, 2, cov = 'clst', opt = 'cov_choice')
ggsave(
'fig_output/simulation/nn_strat_clst_valuation.pdf', device = 'pdf',
width = 6, height = 6.6, units = 'in'
)
library(tidyverse)
library(ggridges)
# simulation results
simul_results_20 <- read_csv('data/simulation/runs/pure_strats/simul_weighted_forages_10_20_25.csv')
simul_results_23 <- read_csv('data/simulation/runs/pure_strats/simul_weighted_forages_10_23_25.csv')
# first col is the pd index, then reorder to place level and forager first
simul_results_20 <- simul_results_20 |>
relocate(strategy, forager, level)
# first col is the pd index, then reorder to place level and forager first
simul_results_23 <- simul_results_23 |>
relocate(strategy, forager, level)
clst_2_results <- simul_results_20 |>
filter(strategy == 'clst') |>
add_column(clst_number = 2)
View(clst_2_results)
clst_3_results <- simul_results_23 |>
filter(strategy == 'clst') |>
add_column(clst_number = 3)
clst_results_comp <- rbind(clst_2_results, clst_3_results)
clst_results_comp |>
group_by(clst_number, forager, level) |>
summarize(
total_time = max(time),
total_dist = sum(dist),
clst_weight = unique(clst_weight)
) |>
ggplot() +
geom_density(aes(x = total_time, color = as.factor(clst_number), fill = as.factor(clst_number))) +
theme_bw() +
facet_wrap(~level)
